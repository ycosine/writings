---
title: 深入JavaScript-类型和值-类型转换
date: 2017-01-01 00::00:00
categories:
- JavaScript
tags:
- JavaScript
- 深入系列
---

# 深入JavaScript-类型转换

> 闇に惑いし哀れな影よ。你能控制，那是好的，你不能控制，那才是坏的。

人们对JavaScript中最大的偏见,最多的指责,莫过于这强制类型转换了。
这里我想说的是，代码是给人看的，而不是仅仅给机器进行执行的。
在编码过程中尽可能将类型转换表达清楚，以免给别人留坑。
而不是为了在代码中"花式炫技"为了类型转换而转换，反而适得其反。

**你能控制，且能让别人看懂的，那就是优秀的**

<!-- more -->
## 类型转换是什么？
我想说一个很多人都没有搞清楚的东西。
什么时候会发生类型转换。
## ToBoolean 布尔值
ToBoolean的expression表达式情况
- 显式的 Boolean() 以及"显式"的 !!
- if(expression)  while(expression) for(..;expression;..;) 中的条件判断
- 三元表达式 expression?a:b
- 逻辑运算符中的 逻辑或，逻辑与 ||  &&  左边的操作数 ！！请注意只有左边

### falsy value 假值 
JavaScript中的值可以分为下面两类
- 1.可以被强制类型转换为false的值
- 2.其他
牢记5大假值
- undefined
- null
- false
- +-0 NaN
- ""
请尤其小心谨慎下面这些容易发生误会的真值
- "false"
- "0"
- "''"
- []
- {}
- [0]
- function(){}

以上值中最坑的应该是[] {},他虽然是真值,但是在ToPromitive解析中却返回的是假值，下面会讲到这个问题

### 补充说明 || 与 &&

JavaScript中的逻辑运算符和别的语言有一些重要的差别
它返回的并不是布尔值,可能你用过很多次都理所当然的认为是,其实只是返回后在条件表达式中理所当然的进行了隐式的布尔转换
它的返回值是两个操作数的一个,即选择两个操作数中的一个,所以也有人称这个运算符为选择运算符

首先对第一个操作数Toboolean后执行条件判断

- || 如果true 返回第一个,否则第二个
- && 如果false 返回第一个,否则第二个

### 宽松相等== 和严格相等 ===

> 一个常见的误区是 == 检查值是否相等, === 检查值和类型是否相等。听起来蛮有道理，但是远不够准确。
一个更常见的见解是把==和以上提到的真值假值混淆在了一起。

**“==允许在相等比较中进行强制类型转换,而===不允许”**
这里涉及到一个很重要,但是总是有人少根筋忘记的事情。
a与b类型不等的时候，到底是什么类型强制转换另一种类型进行比较？

以下规则均套路不同类型的宽松比较情况

Number> String
Number> Boolean
ToPromitive>Object

**简单说数字最大,但是数字的比较最为严格**

1.字符串和布尔值在比较中均转换toNumber继续比较
// 个人建议 在任何情况下都不要使用 == 布尔值,因为布尔值一定会被优先转换成数字
2.null 与 undefined 宽松相等,可以相互进行隐式转换
//但是和所谓的 "" false 不等,原因见1
3.对象在比较中 toprimitive操作(valueOf>toString)
4.请时刻注意自己是在进行toNumber toBoolean toprimitive操作的哪一种
令人窒息的一些非常规情况

``` javascript
"0" == false // true
"" == false // true
[] == false // true
{} == false // false
[] == ![]// true
2 == [2]// true
"" == [null] // ture 特别提醒[null] toString 返回 "" toNumber 0


```

## 补充

显式类型转换发生在静态类型语言的编译时
强制类型转换发生在动态类型语言的运行时

[github上的比较记忆图表](http://dorey.github.io/JavaScript-Equality-Table/)

ES5规范补充
> The Equals Operator ( == )

The production EqualityExpression : EqualityExpression == RelationalExpression is evaluated as follows:

Let lref be the result of evaluating EqualityExpression.
Let lval be GetValue(lref).
Let rref be the result of evaluating RelationalExpression.
Let rval be GetValue(rref).
Return the result of performing abstract equality comparison rval == lval. (see 11.9.3).
11.9.2 The Does-not-equals Operator ( != )

The production EqualityExpression : EqualityExpression != RelationalExpression is evaluated as follows:

Let lref be the result of evaluating EqualityExpression.
Let lval be GetValue(lref).
Let rref be the result of evaluating RelationalExpression.
Let rval be GetValue(rref).
Let r be the result of performing abstract equality comparison rval == lval. (see 11.9.3).
If r is true, return false. Otherwise, return true.
11.9.3 The Abstract Equality Comparison Algorithm

The comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows:

If Type(x) is the same as Type(y), then
If Type(x) is Undefined, return true.
If Type(x) is Null, return true.
If Type(x) is Number, then
If x is NaN, return false.
If y is NaN, return false.
If x is the same Number value as y, return true.
If x is +0 and y is −0, return true.
If x is −0 and y is +0, return true.
Return false.
If Type(x) is String, then return true if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions). Otherwise, return false.
If Type(x) is Boolean, return true if x and y are both true or both false. Otherwise, return false.
Return true if x and y refer to the same object. Otherwise, return false.
If x is null and y is undefined, return true.
If x is undefined and y is null, return true.
If Type(x) is Number and Type(y) is String,
return the result of the comparison x == ToNumber(y).
If Type(x) is String and Type(y) is Number,
return the result of the comparison ToNumber(x) == y.
If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y.
If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).
If Type(x) is either String or Number and Type(y) is Object,
return the result of the comparison x == ToPrimitive(y).
If Type(x) is Object and Type(y) is either String or Number,
return the result of the comparison ToPrimitive(x) == y.
Return false.
NOTE 1 Given the above definition of equality:

String comparison can be forced by: "" + a == "" + b.
Numeric comparison can be forced by: +a == +b.
Boolean comparison can be forced by: !a == !b.
NOTE 2 The equality operators maintain the following invariants:

A != B is equivalent to !(A == B).
A == B is equivalent to B == A, except in the order of evaluation of A and B.
NOTE 3 The equality operator is not always transitive. For example, there might be two distinct String objects, each representing the same String value; each String object would be considered equal to the String value by the == operator, but the two String objects would not be equal to each other. For Example:

new String("a") == "a" and "a" == new String("a")are both true.
new String("a") == new String("a") is false.
NOTE 4 Comparison of Strings uses a simple equality test on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore Strings values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalised form.

11.9.4 The Strict Equals Operator ( === )

The production EqualityExpression : EqualityExpression === RelationalExpression is evaluated as follows:

Let lref be the result of evaluating EqualityExpression.
Let lval be GetValue(lref).
Let rref be the result of evaluating RelationalExpression.
Let rval be GetValue(rref).
Return the result of performing the strict equality comparison rval === lval. (See 11.9.6)
11.9.5 The Strict Does-not-equal Operator ( !== )

The production EqualityExpression : EqualityExpression !== RelationalExpression is evaluated as follows:

Let lref be the result of evaluating EqualityExpression.
Let lval be GetValue(lref).
Let rref be the result of evaluating RelationalExpression.
Let rval be GetValue(rref).
Let r be the result of performing strict equality comparison rval === lval. (See 11.9.6)
If r is true, return false. Otherwise, return true.
11.9.6 The Strict Equality Comparison Algorithm

The comparison x === y, where x and y are values, produces true or false. Such a comparison is performed as follows:

If Type(x) is different from Type(y), return false.
If Type(x) is Undefined, return true.
If Type(x) is Null, return true.
If Type(x) is Number, then
If x is NaN, return false.
If y is NaN, return false.
If x is the same Number value as y, return true.
If x is +0 and y is −0, return true.
If x is −0 and y is +0, return true.
Return false.
If Type(x) is String, then return true if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return false.
If Type(x) is Boolean, return true if x and y are both true or both false; otherwise, return false.
Return true if x and y refer to the same object. Otherwise, return false.
NOTE This algorithm differs from the SameValue Algorithm (9.12) in its treatment of signed zeroes and NaNs.